var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/remark/index.ts
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkFrontmatter from "remark-frontmatter";
import remarkGfm from "remark-gfm";

// src/remark/rehype.ts
import oRehype from "remark-rehype";
function demoHandler(h, _a) {
  var _b = _a, { type, lang, value, position } = _b, props = __objRest(_b, ["type", "lang", "value", "position"]);
  const clonedNode = { lang, value };
  return h(position, "div", __spreadValues({
    type: "previewer",
    lang,
    source: clonedNode.value
  }, props));
}
function rehype() {
  return oRehype.call(this, {
    handlers: {
      demo: demoHandler
    },
    allowDangerousHtml: true
  });
}

// src/remark/raw.ts
import { visit } from "unist-util-visit";
import { raw as hastRaw } from "hast-util-raw";
import { hasProperty as has } from "hast-util-has-property";
function hasComplexProp(props) {
  return Object.values(props).some((prop) => ["object", "function"].includes(typeof prop) || Array.isArray(prop));
}
function raw() {
  return (tree) => {
    const props = [];
    visit(tree, (node) => {
      if (typeof node.tagName === "string" && /^[A-Z]/.test(node.tagName)) {
        node.tagName = `mdoc-raw${node.tagName.replace(/[A-Z]/g, (s) => `-${s.toLowerCase()}`)}`;
      } else if (typeof node.value === "string" && node.type === "raw") {
        node.value = node.value.replace(/(<\/?)([A-Z]\w+)/g, (_, prefix, tagName) => {
          return `${prefix}mdoc-raw${tagName.replace(/[A-Z]/g, (s) => `-${s.toLowerCase()}`)}`;
        });
      }
      if (typeof node.properties === "object" && hasComplexProp(node.properties)) {
        props.push(node.properties);
        node.properties = {
          _index: props.length - 1
        };
      }
      if (typeof node.value === "string" && /<code[^>]*src=/.test(node.value)) {
        node.value = node.value.replace(/ ?\/?>/g, "></code>");
      }
      if (typeof node.value === "string" && /<mdoc-raw-a-p-i/.test(node.value)) {
        node.value = node.value.replace(/ ?\/?>/g, "></mdoc-raw-a-p-i>");
      }
    });
    const parsed = hastRaw(tree);
    visit(parsed, "element", (elm) => {
      if (/^mdoc-raw/.test(elm.tagName)) {
        elm.tagName = elm.tagName.replace("mdoc-raw", "").replace(/-([a-z])/g, (_, word) => word.toUpperCase());
      }
      if (has(elm, "_index")) {
        elm.properties = props[elm.properties._index];
      }
    });
    return parsed;
  };
}

// src/remark/slug.ts
import { toString } from "mdast-util-to-string";
import { isElement as is } from "hast-util-is-element";
import { visit as visit2 } from "unist-util-visit";
import BananaSlug from "github-slugger";
var headings = ["h1", "h2", "h3", "h4", "h5", "h6"];
function filterValidChildren(children) {
  return children.filter((item) => {
    return item.type !== "element" || !/^[A-Z]/.test(item.tagName);
  });
}
var slugs = new BananaSlug();
function remarkSlug() {
  return (tree, vFile) => {
    slugs.reset();
    vFile.data.slugs = [];
    visit2(tree, "element", (node) => {
      if (is(node, headings)) {
        const title = toString({
          children: filterValidChildren(node.children),
          value: node.value
        });
        node.properties.id = slugs.slug(node.properties.id || title.trim(), false);
        node.properties["data-anchor"] = node.properties.id;
        vFile.data.slugs.push({
          depth: parseInt(node.tagName[1], 10),
          text: title,
          id: node.properties.id
        });
        if (!vFile.data.title) {
          vFile.data.title = title;
        }
      }
    });
  };
}

// src/remark/language.ts
import { visit as visit3 } from "unist-util-visit";

// src/utils/yaml.ts
import jsyaml from "js-yaml";

// src/utils/winEOL.ts
var isWindows = typeof process !== "undefined" && process.platform === "win32";
var winEOL = (content) => {
  if (typeof content !== "string") {
    return content;
  }
  return isWindows ? content.replace(/\r/g, "") : content;
};

// src/utils/yaml.ts
var yaml_default = (source) => {
  let parsed;
  try {
    parsed = jsyaml.load(source);
  } catch (err) {
    console.log(err);
  }
  const data = typeof parsed === "object" ? parsed : {};
  if (data.uuid !== void 0) {
    data.uuid = winEOL(source).match(/(?:^|\n)\s*uuid:\s*([^\n]+)/)[1];
  }
  return data;
};

// src/utils/getCodeMeta.ts
var getCodeMeta = (raw3) => {
  const [, comments = "", content = ""] = raw3.replace(/^\n\s*/, "").match(/^(\/\*\*[^]*?\n\s*\*\/)?(?:\s|\n)*([^]+)?$/);
  const frontmatter = comments.replace(/^\/|\/$/g, "").replace(/(^|\n)\s*\*+/g, "$1");
  const meta2 = yaml_default(frontmatter);
  return { content: Object.keys(meta2).length ? content : raw3, meta: meta2 };
};

// src/remark/language.ts
function codeBlockModifierParser(meta2) {
  return (meta2 || "").split("|").reduce((result, item) => {
    item = String.prototype.trim.call(item);
    if (item) {
      result[item] = true;
    }
    return result;
  }, {});
}
function language() {
  return (tree) => {
    visit3(tree, "code", (node) => {
      var _a;
      const modifier = codeBlockModifierParser(node.meta);
      const remarkOpts = this.data("remarkOpts");
      if (((_a = remarkOpts == null ? void 0 : remarkOpts.previewLangs) == null ? void 0 : _a.includes(node.lang)) && (!(remarkOpts == null ? void 0 : remarkOpts.passivePreview) || remarkOpts.passivePreview && modifier.preview)) {
        const { content, meta: meta2 } = getCodeMeta(node.value);
        if (modifier.pure) {
          node.meta = node.meta.replace(/ ?\| ?pure/, "") || null;
        } else {
          node.type = "demo";
          node.meta = meta2;
          node.value = content;
        }
      }
    });
  };
}

// src/remark/meta.ts
import path2 from "path";
import fs2 from "fs";
import slash2 from "slash2";
import { visit as visit4 } from "unist-util-visit";
import { execSync } from "child_process";

// src/utils/moduleResolver.ts
import fs from "fs";
import path from "path";
import slash from "slash2";
import resolve from "enhanced-resolve";
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);
var DEFAULT_EXT = [".tsx", ".jsx", ".js", ".ts"];
function getPkgJsonForPath(absPath) {
  const pkgPath = path.join(absPath, "package.json");
  if (fs.existsSync(pkgPath)) {
    return require2(pkgPath);
  }
  return {};
}
function getPkgAliasForPath(absPath) {
  const result = ["", absPath];
  const pkgPath = path.join(absPath, "package.json");
  if (fs.existsSync(pkgPath)) {
    result[0] = require2(pkgPath).name;
  }
  return result;
}
var getHostPkgAlias = (aliasPath) => {
  const pkgs = [];
  pkgs.push(getPkgAliasForPath(aliasPath || process.cwd()));
  return pkgs;
};
var getPkgPathsFromPath = (identifier) => {
  const matches = identifier.match(/^(.*node_modules)\/((?:@[^/]+\/)?[^/]+)/) || [];
  return {
    absSourcePath: identifier,
    absPkgModulePath: matches[0],
    absNodeModulesPath: matches[1],
    pkgName: matches[2]
  };
};
var getHostPkgPath = (() => {
  let cache;
  return (pkg, aliasPath) => {
    var _a;
    if (!cache) {
      cache = getHostPkgAlias(aliasPath);
    }
    return (_a = cache.find(([name]) => name === pkg)) == null ? void 0 : _a[1];
  };
})();
var getModuleResolvePath = ({
  basePath,
  sourcePath,
  extensions = DEFAULT_EXT,
  silent,
  remarkOpts
}) => {
  var _a;
  const depResolver = resolve.create.sync({
    extensions,
    alias: remarkOpts == null ? void 0 : remarkOpts.alias,
    symlinks: false,
    mainFiles: ["index", "package.json"],
    conditionNames: ["node", "import", "require"]
  });
  try {
    const targetPath = fs.statSync(basePath).isDirectory() ? basePath : path.parse(basePath).dir;
    let resolvePath = depResolver(targetPath, sourcePath);
    if ((_a = remarkOpts == null ? void 0 : remarkOpts.alias) == null ? void 0 : _a[sourcePath]) {
      resolvePath = path.join(resolvePath.substring(0, resolvePath.lastIndexOf(sourcePath)), sourcePath);
    }
    return slash(resolvePath);
  } catch (err) {
    if (!silent) {
      console.error(`[rcdoc]: cannot resolve module ${sourcePath} from ${basePath}`);
    }
    throw err;
  }
};
var getModuleResolvePkg = ({
  basePath,
  sourcePath,
  extensions = DEFAULT_EXT
}) => {
  let version;
  let name;
  let peerDependencies;
  const resolvePath = getModuleResolvePath({ basePath, sourcePath, extensions });
  const { pkgName, absPkgModulePath } = getPkgPathsFromPath(resolvePath);
  const modulePath = getHostPkgPath(pkgName) || absPkgModulePath;
  const pkgPath = path.join(modulePath, "package.json");
  if (modulePath && fs.existsSync(pkgPath)) {
    const pkg = require2(pkgPath);
    version = pkg.version;
    name = pkg.name;
    peerDependencies = pkg.peerDependencies;
  } else {
    console.error(`[rcdoc]: cannot find valid package.json for module ${modulePath}`);
  }
  return { name, version, peerDependencies };
};
var getModuleResolveContent = ({
  basePath,
  sourcePath,
  extensions = DEFAULT_EXT
}) => {
  const resolvePath = getModuleResolvePath({ basePath, sourcePath, extensions });
  return resolvePath ? fs.readFileSync(resolvePath, "utf8").toString() : "";
};

// src/remark/meta.ts
function meta() {
  return (tree, vFile) => {
    if (this.data("fileAbsPath")) {
      const filePath = slash2(path2.relative(process.cwd(), this.data("fileAbsPath")));
      vFile.data.filePath = filePath;
      try {
        vFile.data.updatedTime = parseInt(execSync(`git log -1 --format=%at ${this.data("fileAbsPath")}`, {
          stdio: "pipe"
        }).toString(), 10) * 1e3;
      } catch (err) {
      }
      if (Number.isNaN(Number(vFile.data.updatedTime))) {
        vFile.data.updatedTime = Math.floor(fs2.lstatSync(this.data("fileAbsPath")).mtimeMs);
      }
      if (/(?<!\/src)\/README(\.[\w-]+)?\.md/i.test(slash2(this.data("fileAbsPath")))) {
        try {
          getModuleResolvePath({
            extensions: [".tsx"],
            basePath: process.cwd(),
            sourcePath: path2.dirname(this.data("fileAbsPath")),
            silent: true
          });
          vFile.data.componentName = path2.basename(path2.parse(this.data("fileAbsPath")).dir);
        } catch (err) {
        }
      }
    }
    visit4(tree, "yaml", (node) => {
      const data = yaml_default(node.value);
      vFile.data.frontmatter = Object.assign(vFile.data.frontmatter || {}, data);
    });
  };
}

// src/remark/pre.ts
import { visit as visit5 } from "unist-util-visit";
import { toString as toString2 } from "hast-util-to-string";
import { raw as raw2 } from "hast-util-raw";
function createSourceCode(lang, code2, position) {
  return {
    type: "element",
    tagName: "Previewer",
    position,
    properties: {
      code: new String(JSON.stringify(code2)),
      lang: lang || "unknown"
    }
  };
}
function pre() {
  return (tree) => {
    visit5(tree, "element", (node, i, parent) => {
      var _a, _b, _c;
      if (node.tagName === "pre" && ((_b = (_a = node.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.tagName) === "code") {
        const cls = node.children[0].properties.className || [];
        const lang = ((_c = cls.join("").match(/language-(\w+)(?:$| )/)) == null ? void 0 : _c[1]) || "unknown";
        parent.children.splice(i, 1, createSourceCode(lang, winEOL(toString2(node.children[0]).trim()), node.position));
      }
    });
    visit5(tree, "raw", (node, i, parent) => {
      if (/^<pre/.test(node.value)) {
        const parsed = raw2(node);
        if (parsed.tagName === "pre") {
          const [, content] = winEOL(node.value).match(/^<pre[^>]*>\n?([^]*?)<\/pre>$/) || [];
          if (content) {
            parent.children.splice(i, 1, createSourceCode(parsed.properties.lang, content.trim(), node.position));
          }
        }
      }
    });
  };
}

// src/remark/code.ts
import fs3 from "fs";
import path3 from "path";
import { isElement as is2 } from "hast-util-is-element";
import { hasProperty as has2 } from "hast-util-has-property";
import { visit as visit6 } from "unist-util-visit";

// src/utils/parseElmAttrToProps.ts
var ATTR_MAPPING = {
  hideactions: "hideActions",
  defaultshowcode: "defaultShowCode",
  skipnodemodules: "skipNodeModules",
  skippropswithoutdoc: "skipPropsWithoutDoc",
  hidetitle: "hideTitle",
  demourl: "demoUrl"
};
var parseElmAttrToProps = (attrs) => {
  const parsed = Object.assign({}, attrs);
  Object.entries(ATTR_MAPPING).forEach(([mark, attr]) => {
    if (parsed[mark] !== void 0) {
      parsed[attr] = parsed[mark];
      delete parsed[mark];
    }
  });
  Object.keys(parsed).forEach((attr) => {
    if (parsed[attr] === "") {
      parsed[attr] = true;
    }
  });
  Object.keys(parsed).forEach((attr) => {
    if (/^(\[|{)[^]*(]|})$/.test(parsed[attr])) {
      try {
        parsed[attr] = JSON.parse(parsed[attr]);
      } catch (err) {
      }
    }
  });
  return parsed;
};

// src/remark/code.ts
function code() {
  return (tree) => {
    visit6(tree, "element", (node, index, parent) => {
      if (is2(node, "code") && has2(node, "src")) {
        const _a = node.properties, { src } = _a, attrs = __objRest(_a, ["src"]);
        const props = {
          source: "",
          lang: path3.extname(src).slice(1),
          filePath: path3.join(path3.dirname(this.data("fileAbsPath")), src)
        };
        const parsedAttrs = parseElmAttrToProps(attrs);
        try {
          props.source = fs3.readFileSync(props.filePath, "utf8").toString();
          props.lang = path3.extname(props.filePath).slice(1);
        } catch (err) {
        }
        parent.tagName = "div";
        parent.children.splice(index, 1, {
          type: "element",
          tagName: "div",
          position: node.position,
          properties: __spreadProps(__spreadValues({
            type: "previewer"
          }, props), {
            src,
            meta: __spreadValues({}, parsedAttrs)
          })
        });
      }
    });
  };
}

// src/remark/previewer.ts
import fs5 from "fs";
import { visit as visit7 } from "unist-util-visit";
import slash4 from "slash2";
import path5 from "path";

// src/utils/analyzeDeps.ts
import path4 from "path";
import slash3 from "slash2";
import crypto from "crypto";
import { transformSync } from "@babel/core";
import * as types from "@babel/types";
import _traverse from "@babel/traverse";

// src/utils/cache.ts
import fs4 from "fs";
var FileCache = class {
  cache = {};
  add(filePath, value, key) {
    this.cache[key || filePath] = {
      filePath,
      value,
      updatedTime: fs4.lstatSync(filePath).mtimeMs
    };
  }
  get(key) {
    let result;
    if (this.cache[key] && fs4.lstatSync(this.cache[key].filePath).mtimeMs === this.cache[key].updatedTime) {
      result = this.cache[key].value;
    }
    return result;
  }
};

// src/utils/analyzeDeps.ts
import { createRequire as createRequire2 } from "module";
var require3 = createRequire2(import.meta.url);
var traverse = _traverse.default;
var cachers = {
  file: new FileCache(),
  content: new FileCache()
};
var getContentHash = (content) => {
  const hash = crypto.createHash("sha256");
  hash.update(content);
  return hash.digest("hex");
};
var LOCAL_DEP_EXT = [".jsx", ".tsx", ".js", ".ts"];
var LOCAL_MODULE_EXT = [...LOCAL_DEP_EXT, ".json"];
var PLAIN_TEXT_EXT = [...LOCAL_MODULE_EXT, ".less", ".css", ".scss", ".sass", ".styl"];
function analyzeDeps(raw3, {
  isTSX,
  fileAbsPath,
  entryAbsPath,
  files = {},
  remarkOpts,
  rootPkgJson
}) {
  const cacheKey = fileAbsPath.endsWith(".md") ? `${fileAbsPath}-${getContentHash(raw3)}` : fileAbsPath;
  const dependencies = {};
  let cache = fileAbsPath && cachers.file.get(fileAbsPath);
  if (!cache) {
    cache = { dependencies: [], files: [] };
    let ast;
    try {
      ({ ast } = transformSync(raw3, {
        filename: fileAbsPath.replace(/\.md$/, isTSX ? ".tsx" : ".jsx"),
        presets: [
          [require3.resolve("@babel/preset-typescript"), { isTSX: true, allExtensions: true }]
        ],
        ast: true,
        babelrc: false,
        configFile: false
      }));
    } catch (error) {
      console.log("transformSync: ", error);
    }
    traverse(ast, {
      ImportDeclaration(callPath) {
        var _a, _b;
        const callPathNode = callPath.node;
        if (types.isProgram(callPath.parent)) {
          const requireStr = callPathNode.source.value;
          if ((rootPkgJson == null ? void 0 : rootPkgJson.name) === requireStr) {
            cache.dependencies.push({
              resolvePath: "",
              name: requireStr,
              version: rootPkgJson.version,
              peerDeps: []
            });
            return;
          }
          if ((_a = remarkOpts == null ? void 0 : remarkOpts.localPkgs) == null ? void 0 : _a[requireStr]) {
            cache.dependencies.push({
              resolvePath: "",
              name: requireStr,
              version: (_b = remarkOpts == null ? void 0 : remarkOpts.localPkgs) == null ? void 0 : _b[requireStr].version,
              peerDeps: []
            });
            return;
          }
          const resolvePath = getModuleResolvePath({
            basePath: fileAbsPath,
            sourcePath: requireStr,
            extensions: LOCAL_MODULE_EXT,
            remarkOpts
          });
          const resolvePathParsed = path4.parse(resolvePath);
          if (resolvePath.includes("node_modules")) {
            const pkg = getModuleResolvePkg({
              basePath: fileAbsPath,
              sourcePath: resolvePath,
              extensions: LOCAL_MODULE_EXT
            });
            const css = getCSSForDep(pkg.name);
            const peerDeps = [];
            Object.keys(pkg.peerDependencies || {}).forEach((dep) => {
              const peerCSS = getCSSForDep(dep);
              peerDeps.push({
                name: dep,
                version: pkg.peerDependencies[dep],
                css: peerCSS
              });
            });
            cache.dependencies.push({
              resolvePath,
              name: pkg.name,
              version: pkg.version,
              css,
              peerDeps
            });
          } else if (PLAIN_TEXT_EXT.includes(resolvePathParsed.ext) && resolvePath !== slash3(entryAbsPath || "") && requireStr.startsWith(".")) {
            const filename = slash3(path4.relative(entryAbsPath || fileAbsPath, resolvePath)).replace(/(\.\/|\..\/)/g, "");
            cache.files.push({
              resolvePath,
              requireStr,
              filename
            });
          }
        }
      }
    });
  }
  cache.dependencies.forEach((item) => {
    dependencies[item.name] = __spreadValues({
      version: item.version
    }, item.css ? { css: item.css } : {});
  });
  cache.dependencies.reduce((result, item) => result.concat(item.peerDeps), []).filter((item) => !dependencies[item]).forEach((item) => {
    dependencies[item.name] = __spreadValues({
      version: item.version
    }, item.css ? { css: item.css } : {});
  });
  cache.files.filter((item) => {
    return !files[item.filename];
  }).forEach((item) => {
    const ext = path4.extname(item.resolvePath);
    files[item.filename] = cachers.content.get(item.resolvePath) || {
      import: item.requireStr,
      fileAbsPath: item.resolvePath
    };
    cachers.content.add(item.resolvePath, files[item.filename]);
    if (LOCAL_DEP_EXT.includes(ext)) {
      const content = getModuleResolveContent({
        basePath: fileAbsPath,
        sourcePath: item.resolvePath,
        extensions: LOCAL_DEP_EXT
      });
      files[item.filename].content = content;
      const result = analyzeDeps(content, {
        isTSX: /\.tsx?/.test(ext),
        fileAbsPath: item.resolvePath,
        entryAbsPath: entryAbsPath || fileAbsPath,
        files,
        remarkOpts,
        rootPkgJson
      });
      Object.assign(files, result.files);
      Object.assign(dependencies, result.dependencies);
    }
  });
  if (fileAbsPath) {
    cachers.file.add(fileAbsPath, cache, cacheKey);
  }
  return { files, dependencies };
}
function getCSSForDep(dep) {
  const pkgWithoutGroup = dep.match(/([^\/]+)$/)[1];
  const guessFiles = [
    `${pkgWithoutGroup}`,
    ...pkgWithoutGroup.includes("-") ? [pkgWithoutGroup.replace(/-/g, ""), pkgWithoutGroup.split("-")[1]] : [],
    "main",
    "style",
    "index"
  ].reduce((files, name) => files.concat([`${name}.css`, `${name}.min.css`]), []);
  for (let i = 0; i <= guessFiles.length; i += 1) {
    const file = guessFiles[i];
    try {
      const guessFilePath = `${dep}/dist/${file}`;
      getModuleResolvePath({
        basePath: process.cwd(),
        sourcePath: guessFilePath,
        silent: true
      });
      return guessFilePath;
    } catch (err) {
    }
  }
}
var analyzeDeps_default = analyzeDeps;

// src/utils/getPreviewerAnalyzeData.ts
var getPreviewerAnalyzeData = ({
  mdAbsPath,
  node,
  remarkOpts,
  rootPkgJson
}) => {
  var _a;
  const fileAbsPath = node.properties.filePath || mdAbsPath;
  let files = {};
  let dependencies = {};
  if (!((_a = node.properties.meta) == null ? void 0 : _a.inline)) {
    try {
      ({ files, dependencies } = analyzeDeps_default(node.properties.source, {
        isTSX: /^tsx?$/.test(node.properties.lang),
        fileAbsPath,
        remarkOpts,
        rootPkgJson
      }));
    } catch {
    }
  }
  return {
    previewerProps: {
      sources: __spreadValues({
        _: {
          [node.properties.lang]: node.properties.source
        }
      }, Object.keys(files).reduce((result, file) => __spreadProps(__spreadValues({}, result), {
        [file]: {
          import: files[file].import,
          path: files[file].fileAbsPath,
          content: files[file].content
        }
      }), {})),
      dependencies
    }
  };
};

// src/remark/previewer.ts
var externalCache = /* @__PURE__ */ new Map();
var externalIdMap = /* @__PURE__ */ new Map();
var mdCodeBlockIdMap = /* @__PURE__ */ new Map();
function getPreviewerId(yaml, mdAbsPath, codeAbsPath) {
  let id = yaml.identifier || yaml.uuid;
  if (yaml.inline) {
    return;
  }
  if (!id) {
    if (mdAbsPath === codeAbsPath) {
      const idMap = mdCodeBlockIdMap.get(mdAbsPath);
      id = [idMap.id, idMap.count, "demo"].filter(Boolean).join("-");
      const currentIdCount = idMap.map.get(id) || 0;
      idMap.map.set(id, currentIdCount + 1);
      id += currentIdCount ? `-${currentIdCount}` : "";
    } else {
      id = externalCache.get(codeAbsPath);
      if (!id) {
        const words = slash4(codeAbsPath).replace(/(?:\/index)?(\.[\w-]+)?\.\w+$/, "$1").split(/\//).map((w) => w.toLowerCase());
        const demoName = words[words.length - 1] || "demo";
        const prefix = words.slice(0, -1).filter((word) => !/^(src|_?demos?|_?examples?)$/.test(word)).pop();
        id = `${prefix}-${demoName}`;
        const currentIdCount = externalIdMap.get(id) || 0;
        externalIdMap.set(id, currentIdCount + 1);
        id += currentIdCount ? `-${currentIdCount}` : "";
        externalCache.set(codeAbsPath, id);
      }
    }
  }
  return id;
}
function getDemoDeps(props, lang) {
  return __spreadValues(__spreadValues({}, Object.entries(props.dependencies || {}).reduce((deps, [pkg, { version }]) => Object.assign(deps, {
    [pkg]: {
      type: "NPM",
      value: version
    }
  }), {})), Object.entries(props.sources).reduce((result, [file, item]) => {
    return Object.assign(result, __spreadValues({}, file === "_" ? {
      [`index.${lang}`]: {
        type: "FILE",
        value: item[lang]
      }
    } : {
      [file]: {
        type: "FILE",
        value: item.content || fs5.readFileSync(item.path, "utf-8").toString()
      }
    }));
  }, {}));
}
function previewer() {
  return (tree, vFile) => {
    const fileAbsPath = this.data("fileAbsPath");
    const remarkOpts = this.data("remarkOpts");
    if (fileAbsPath) {
      const mapObj = mdCodeBlockIdMap.get(fileAbsPath);
      if (!mapObj) {
        const prefix = vFile.data.componentName || path5.basename(slash4(fileAbsPath).replace(/(?:\/(?:index|readme))?(\.[\w-]+)?\.md/i, "$1"));
        mdCodeBlockIdMap.set(fileAbsPath, {
          id: prefix,
          count: Array.from(mdCodeBlockIdMap.values()).filter((m) => m.id === prefix).length,
          map: /* @__PURE__ */ new Map()
        });
      } else {
        mapObj.map = /* @__PURE__ */ new Map();
      }
    }
    visit7(tree, "element", (node, i, parent) => {
      var _a, _b, _c;
      if (node.tagName === "div" && ((_a = node.properties) == null ? void 0 : _a.type) === "previewer") {
        const identifier = getPreviewerId(node.properties.meta, fileAbsPath, node.properties.filePath || fileAbsPath);
        const result = getPreviewerAnalyzeData({
          node,
          mdAbsPath: fileAbsPath,
          remarkOpts: this.data("remarkOpts"),
          rootPkgJson: this.data("rootPkgJson")
        });
        let previewerProps;
        const decorateResult = (o) => {
          if (node.properties.filePath) {
            const { meta: meta2 } = getCodeMeta(node.properties.source);
            node.properties._ATTR_META = node.properties._ATTR_META || node.properties.meta;
            node.properties.meta = Object.assign(meta2, node.properties._ATTR_META);
          }
          o.previewerProps.componentName = vFile.data.componentName;
          Object.assign(o.previewerProps, node.properties.meta);
          o.previewerProps.identifier = identifier;
          o.previewerProps.dependencies = o.previewerProps.dependencies || {};
          o.previewerProps.sources = o.previewerProps.sources || {};
          if (!o.previewerProps.inline) {
            o.previewerProps.dependencies = getDemoDeps(o.previewerProps, node.properties.lang);
          }
          return o;
        };
        ({ previewerProps } = decorateResult(result));
        const componentProps = {
          lang: node.properties.lang,
          dependencies: previewerProps.dependencies,
          key: previewerProps.identifier,
          meta: node.properties.meta
        };
        vFile.data.demos = (vFile.data.demos || []).concat({
          name: `${remarkOpts.prefix}${(((_b = vFile.data.demos) == null ? void 0 : _b.length) || 0) + 1}`,
          code: (_c = node.properties) == null ? void 0 : _c.source,
          inline: previewerProps.inline,
          filePath: node.properties.filePath,
          props: componentProps
        });
        if (previewerProps.inline) {
          parent.children[i] = {
            previewer: true,
            type: "element",
            tagName: `${remarkOpts.prefix}${vFile.data.demos.length}`
          };
        } else {
          parent.children[i] = {
            previewer: true,
            type: "element",
            tagName: "Previewer",
            properties: {
              "data-previewer-props-replaced": `${vFile.data.demos.length}`
            },
            children: [
              {
                type: "element",
                tagName: `${remarkOpts.prefix}${vFile.data.demos.length}`,
                properties: {}
              }
            ]
          };
        }
      }
    });
  };
}

// src/remark/jsxify.ts
import { visit as visit8 } from "unist-util-visit";
import toJSX from "@mapbox/hast-util-to-jsx";
var formatJSXProps = (props) => {
  const OMIT_NULL_PROPS = ["alt", "align"];
  return Object.keys(props || {}).reduce((result, key) => {
    if (props[key] !== null || !OMIT_NULL_PROPS.includes(key)) {
      result[key] = props[key];
    }
    if (!(props[key] instanceof String) && props[key] !== null && (typeof props[key] === "object" || Array.isArray(props[key]))) {
      result[key] = new String(JSON.stringify(props[key]));
    }
    if (key === "className" && Array.isArray(props[key])) {
      result[key] = props[key].join(" ");
    }
    return result;
  }, {});
};
function jsxify() {
  const compiler = (tree) => {
    const remarkOpts = this.data("remarkOpts");
    visit8(tree, "element", (node) => {
      node.properties = formatJSXProps(node.properties);
    });
    let JSX = toJSX(tree) || "";
    JSX = JSX.replace(/data-previewer-props-replaced="([^"]+)"/g, `{...${remarkOpts.prefix}$1PreviewerProps}`);
    if (remarkOpts == null ? void 0 : remarkOpts.replaceHtml) {
      JSX = remarkOpts.replaceHtml(JSX);
    }
    return JSX;
  };
  Object.assign(this, { Compiler: compiler });
  return null;
}

// src/remark/docgen.ts
import path6 from "path";
import deepmerge from "deepmerge";
import { isElement as is3 } from "hast-util-is-element";
import { hasProperty as has3 } from "hast-util-has-property";
import { visit as visit9 } from "unist-util-visit";

// src/docgen/parser.ts
import * as parser from "react-docgen-typescript";
import { buildFilter as getBuiltinFilter } from "react-docgen-typescript/lib/buildFilter.js";
var cacher = new FileCache();
var DEFAULT_EXPORTS = [
  "default",
  "__function",
  "Stateless",
  "StyledComponentClass",
  "StyledComponent",
  "FunctionComponent",
  "StatelessComponent",
  "ForwardRefExoticComponent"
];
function extraFilter(prop, opts) {
  if (opts.skipNodeModules && prop.declarations.find((d) => d.fileName.includes("node_modules"))) {
    return false;
  }
  return true;
}
var parser_default = (filePath, _a = {}, remarkOpts) => {
  var _b = _a, { componentName } = _b, filterOpts = __objRest(_b, ["componentName"]);
  var _a2;
  let definitions = cacher.get(filePath);
  let localFilter = filterOpts;
  const globalFilter = (_a2 = remarkOpts == null ? void 0 : remarkOpts.apiParser) == null ? void 0 : _a2.propFilter;
  const isDefaultRegExp = new RegExp(`^${componentName}$`, "i");
  switch (typeof globalFilter) {
    case "function":
      localFilter = globalFilter;
      break;
    default:
      localFilter = ((mergedOpts) => (prop, component) => {
        const builtinFilter = getBuiltinFilter({ propFilter: mergedOpts });
        return builtinFilter(prop, component) && extraFilter(prop, mergedOpts);
      })(Object.assign({}, globalFilter, localFilter));
  }
  if (!definitions) {
    let defaultDefinition;
    definitions = {};
    parser.withCompilerOptions({ esModuleInterop: true, jsx: "preserve" }, {
      savePropValueAsString: true,
      shouldExtractLiteralValuesFromEnum: true,
      shouldRemoveUndefinedFromOptional: true,
      componentNameResolver: (source) => {
        return DEFAULT_EXPORTS.includes(source.getName()) ? componentName : void 0;
      },
      propFilter: localFilter
    }).parse(filePath).forEach((item) => {
      const exportName = isDefaultRegExp.test(item.displayName) ? "default" : item.displayName;
      const props = Object.entries(item.props).map(([identifier, prop]) => {
        const result = { identifier };
        const fields = ["identifier", "description", "type", "defaultValue", "required"];
        const localeDescReg = /(?:^|\n+)@description\s+/;
        fields.forEach((field) => {
          switch (field) {
            case "type":
              result.type = prop.type.raw || prop.type.name;
              break;
            case "description":
              if (localeDescReg.test(prop.description)) {
                const groups = prop.description.split(localeDescReg).filter(Boolean);
                groups == null ? void 0 : groups.forEach((str) => {
                  const [, locale, content] = str.match(/^(\.[\w-]+)?\s*([^]*)$/);
                  result[`description${locale || ""}`] = content;
                });
              } else if (prop.description) {
                result.description = prop.description;
              }
              break;
            case "defaultValue":
              if (prop[field]) {
                result.default = prop[field].value;
              }
              break;
            default:
              if (prop[field]) {
                result[field] = prop[field];
              }
          }
        });
        return result;
      });
      if (exportName === "default") {
        defaultDefinition = props;
      } else {
        definitions[exportName] = props;
      }
    });
    if (defaultDefinition) {
      definitions = Object.assign({ default: defaultDefinition }, definitions);
    }
  }
  cacher.add(filePath, definitions);
  return definitions;
};

// src/remark/docgen.ts
function serializeAPINodes(node, identifier, definitions) {
  const parsedAttrs = parseElmAttrToProps(node.properties);
  const expts = parsedAttrs.exports || Object.keys(definitions);
  const showTitle = !parsedAttrs.hideTitle;
  const nodes = expts.reduce((list, expt, i) => {
    const isInsertAPITitle = expt === "default" || !i && !parsedAttrs.exports;
    const isInsertSubTitle = expt !== "default";
    const apiNode = deepmerge({}, node);
    if (showTitle && isInsertAPITitle) {
      list.push({
        type: "element",
        tagName: "h2",
        properties: {},
        children: [{ type: "text", value: "API" }]
      }, {
        type: "text",
        value: "\n"
      });
    }
    if (showTitle && isInsertSubTitle) {
      list.push({
        type: "element",
        tagName: "h3",
        properties: { id: `api-${expt.toLowerCase()}` },
        children: [{ type: "text", value: expt }]
      }, {
        type: "text",
        value: "\n"
      });
    }
    delete apiNode.properties.exports;
    apiNode.properties.identifier = identifier;
    apiNode.properties.export = expt;
    apiNode.properties.definitions = definitions[expt];
    list.push(apiNode);
    return list;
  }, []);
  return nodes;
}
function guessComponentName(fileAbsPath) {
  const parsed = path6.parse(fileAbsPath);
  if (["index", "index.d"].includes(parsed.name)) {
    return path6.basename(parsed.dir.replace(/(\/|\\)(src|lib)$/, ""));
  }
  return parsed.name;
}
function docgen() {
  return (tree, vFile) => {
    const remarkOpts = this.data("remarkOpts");
    visit9(tree, "element", (node, i, parent) => {
      if (is3(node, "API") && (remarkOpts == null ? void 0 : remarkOpts.apiParser)) {
        let identifier;
        let definitions;
        const parseOpts = parseElmAttrToProps(node.properties);
        if (has3(node, "src")) {
          const src = node.properties.src || "";
          let absPath = path6.join(path6.dirname(this.data("fileAbsPath")), src);
          try {
            absPath = getModuleResolvePath({
              basePath: process.cwd(),
              sourcePath: src,
              silent: true
            });
          } catch (err) {
          }
          const componentName = node.properties.identifier || guessComponentName(absPath);
          parseOpts.componentName = componentName;
          definitions = parser_default(absPath, parseOpts);
          identifier = componentName || src;
        } else if (vFile.data.componentName) {
          try {
            const sourcePath = getModuleResolvePath({
              basePath: process.cwd(),
              sourcePath: path6.dirname(this.data("fileAbsPath")),
              silent: true
            });
            parseOpts.componentName = vFile.data.componentName;
            definitions = parser_default(sourcePath, parseOpts);
            identifier = vFile.data.componentName;
          } catch (err) {
          }
        }
        if (identifier && definitions) {
          parent.children.splice(i, 1, {
            type: "element",
            tagName: "div",
            position: node.position,
            children: serializeAPINodes(node, identifier, definitions)
          });
          vFile.data.definitions = definitions;
        }
      }
    });
  };
}

// src/remark/index.ts
var CWD = process.cwd();
var defaultOpts = {
  prefix: "MdocDemo",
  previewLangs: ["tsx", "jsx"],
  apiParser: true
};
async function remark(source, id, options = {}) {
  const remarkOpts = Object.assign({}, defaultOpts, options);
  const rootPkgJson = getPkgJsonForPath(CWD);
  const processor = await unified().use(remarkParse).use(remarkGfm).use(remarkFrontmatter).use(meta).use(language).use(rehype).use(pre).use(raw).use(code).use(docgen).use(remarkSlug).use(previewer).data("fileAbsPath", id).data("remarkOpts", remarkOpts).data("rootPkgJson", rootPkgJson);
  processor.use(jsxify);
  const { data, value } = processor.processSync(source);
  const {
    demos = [],
    slugs: slugs2,
    frontmatter,
    title,
    updatedTime
  } = data;
  return { demos, slugs: slugs2, frontmatter, title, updatedTime, value: value.toString() };
}

// src/index.ts
var src_default = remark;
export {
  src_default as default
};
