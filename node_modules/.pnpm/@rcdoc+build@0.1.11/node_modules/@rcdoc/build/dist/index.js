var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/build.ts
var import_fs_extra2 = require("fs-extra");
var import_path6 = require("path");
var assert = __toESM(require("assert"));
var import_lodash = require("lodash");
var import_signale2 = __toESM(require("signale"));
var import_chalk3 = __toESM(require("chalk"));

// src/babel.ts
var import_path2 = require("path");
var import_fs_extra = require("fs-extra");
var import_vinyl_fs = __toESM(require("vinyl-fs"));
var import_signale = __toESM(require("signale"));
var import_through2 = __toESM(require("through2"));
var import_slash2 = __toESM(require("slash2"));
var babel = __toESM(require("@babel/core"));
var import_gulp_typescript = __toESM(require("gulp-typescript"));
var import_gulp_less = __toESM(require("gulp-less"));
var import_gulp_if = __toESM(require("gulp-if"));
var import_chalk = __toESM(require("chalk"));

// src/getBabelConfig.ts
var import_path = require("path");
function transformImportLess2Css() {
  return {
    name: "transform-import-less-to-css",
    visitor: {
      ImportDeclaration(path, source) {
        const re = /\.less$/;
        if (re.test(path.node.source.value)) {
          path.node.source.value = path.node.source.value.replace(re, ".css");
        }
      }
    }
  };
}
function getBabelConfig_default(opts) {
  const {
    target,
    loose,
    typescript,
    type,
    runtimeHelpers,
    filePath,
    browserFiles,
    nodeFiles,
    nodeVersion,
    lazy,
    lessInBabelMode,
    needTransform
  } = opts;
  let isBrowser = target === "browser";
  if (filePath) {
    if ((0, import_path.extname)(filePath) === ".tsx" || (0, import_path.extname)(filePath) === ".jsx") {
      isBrowser = true;
    } else {
      if (isBrowser) {
        if (nodeFiles == null ? void 0 : nodeFiles.includes(filePath))
          isBrowser = false;
      } else {
        if (browserFiles == null ? void 0 : browserFiles.includes(filePath))
          isBrowser = true;
      }
    }
  }
  const targets = isBrowser ? { browsers: ["last 2 versions", "IE 10"] } : { node: nodeVersion || 6 };
  return {
    opts: {
      presets: needTransform ? [
        [
          require.resolve("@babel/preset-env"),
          {
            targets,
            modules: type === "esm" ? false : "auto",
            loose
          }
        ],
        ...typescript ? [require.resolve("@babel/preset-typescript")] : [],
        ...isBrowser ? [require.resolve("@babel/preset-react")] : []
      ] : [],
      plugins: [
        ...type === "cjs" ? [
          [
            require.resolve("@babel/plugin-transform-modules-commonjs"),
            {
              lazy: true
            }
          ]
        ] : [],
        ...lessInBabelMode ? [transformImportLess2Css] : [],
        ...isBrowser ? [require.resolve("babel-plugin-react-require")] : [],
        ...runtimeHelpers ? [
          [
            require.resolve("@babel/plugin-transform-runtime"),
            {
              useESModules: isBrowser && type === "esm",
              version: require("@babel/runtime/package.json").version
            }
          ]
        ] : []
      ]
    },
    isBrowser
  };
}

// src/babel.ts
function getSrcPath(cwd, entry) {
  const entryPath = Array.isArray(entry) ? entry[0] : entry;
  const stat = (0, import_fs_extra.lstatSync)(entryPath);
  if (stat.isDirectory()) {
    return (0, import_path2.join)(cwd, entryPath);
  }
  return (0, import_path2.join)(cwd, (0, import_path2.dirname)(entryPath));
}
async function babel_default(opts) {
  const {
    cwd,
    rootPath,
    type,
    watch,
    needTransform,
    log,
    bundleOpts: {
      entry,
      outDir = "./",
      target = "browser",
      runtimeHelpers,
      extraBabelPresets = [],
      extraBabelPlugins = [],
      browserFiles = [],
      nodeFiles = [],
      nodeVersion,
      disableTypeCheck,
      lessInBabelMode,
      loose
    }
  } = opts;
  const srcPath = getSrcPath(cwd, entry);
  const targetModeOps = type === "esm" ? opts.bundleOpts.esm : opts.bundleOpts.cjs;
  let targetDir = type === "esm" ? "es" : "cjs";
  if (typeof targetModeOps !== "boolean" && targetModeOps.dist) {
    targetDir = targetModeOps.dist;
  }
  const targetPath = (0, import_path2.join)(cwd, outDir, targetDir);
  log == null ? void 0 : log(import_chalk.default.gray(`Clean ${targetDir} directory`));
  await (0, import_fs_extra.remove)(targetPath);
  function transform2(opts2) {
    var _a;
    const { file, type: type2 } = opts2;
    let { opts: babelOpts, isBrowser } = getBabelConfig_default({
      target,
      type: type2,
      loose,
      typescript: true,
      runtimeHelpers,
      filePath: (0, import_slash2.default)((0, import_path2.relative)(cwd, file.path)),
      browserFiles,
      nodeFiles,
      nodeVersion,
      lessInBabelMode,
      needTransform
    });
    babelOpts.presets.push(...extraBabelPresets);
    babelOpts.plugins.push(...extraBabelPlugins);
    const relFile = (0, import_slash2.default)(file.path).replace(`${cwd}/`, "");
    log == null ? void 0 : log(`Transform to ${type2} for ${import_chalk.default[isBrowser ? "yellow" : "blue"](relFile)}`);
    return (_a = babel.transform(file.contents, __spreadProps(__spreadValues({}, babelOpts), {
      filename: file.path,
      configFile: false
    }))) == null ? void 0 : _a.code;
  }
  function getTsconfigCompilerOptions(path) {
    const config = (0, import_fs_extra.readJSONSync)(path, "utf-8");
    return config ? config.compilerOptions : void 0;
  }
  function getTSConfig() {
    const tsconfigPath = (0, import_path2.join)(cwd, "tsconfig.json");
    if ((0, import_fs_extra.existsSync)(tsconfigPath)) {
      return getTsconfigCompilerOptions(tsconfigPath) || {};
    }
    if (rootPath && (0, import_fs_extra.existsSync)((0, import_path2.join)(rootPath, "tsconfig.json"))) {
      return getTsconfigCompilerOptions((0, import_path2.join)(rootPath, "tsconfig.json")) || {};
    }
    return {};
  }
  function createStream(src) {
    const tsConfig = getTSConfig();
    const babelTransformRegexp = disableTypeCheck ? /\.(t|j)sx?$/ : /\.jsx?$/;
    function isTsFile(path) {
      return /\.tsx?$/.test(path) && !path.endsWith(".d.ts");
    }
    function isTransform(path) {
      return babelTransformRegexp.test(path) && !path.endsWith(".d.ts");
    }
    return import_vinyl_fs.default.src(src, {
      allowEmpty: true,
      base: srcPath
    }).pipe((0, import_gulp_if.default)((f) => !disableTypeCheck && isTsFile(f.path), (0, import_gulp_typescript.default)(tsConfig))).pipe((0, import_gulp_if.default)((f) => lessInBabelMode && /\.less$/.test(f.path), (0, import_gulp_less.default)(lessInBabelMode || {}))).pipe((0, import_gulp_if.default)((f) => isTransform(f.path), import_through2.default.obj((file, env, cb) => {
      try {
        file.contents = Buffer.from(transform2({
          file,
          type
        }));
        file.path = file.path.replace((0, import_path2.extname)(file.path), ".js");
        cb(null, file);
      } catch (e) {
        import_signale.default.error(`Compiled faild: ${file.path}`);
        console.log(e);
        cb(null);
      }
    }))).pipe(import_vinyl_fs.default.dest(targetPath));
  }
  return new Promise((resolve2) => {
    const patterns = [
      (0, import_path2.join)(srcPath, "**/*"),
      `!${(0, import_path2.join)(srcPath, "**/fixtures{,/**}")}`,
      `!${(0, import_path2.join)(srcPath, "**/demos{,/**}")}`,
      `!${(0, import_path2.join)(srcPath, "**/demo{,/**}")}`,
      `!${(0, import_path2.join)(srcPath, "**/__test__{,/**}")}`,
      `!${(0, import_path2.join)(srcPath, "**/__tests__{,/**}")}`,
      `!${(0, import_path2.join)(srcPath, "**/*.mdx")}`,
      `!${(0, import_path2.join)(srcPath, "**/*.md")}`,
      `!${(0, import_path2.join)(srcPath, "**/*.+(test|e2e|spec).+(js|jsx|ts|tsx)")}`,
      `!${(0, import_path2.join)(srcPath, "**/tsconfig{,.*}.json")}`,
      `!${(0, import_path2.join)(srcPath, ".umi{,-production,-test}{,/**}")}`
    ];
    createStream(patterns).on("end", () => {
      if (watch) {
        log == null ? void 0 : log(import_chalk.default.magenta(`Start watching ${(0, import_slash2.default)(srcPath).replace(`${cwd}/`, "")} directory...`));
      }
      resolve2(true);
    });
  });
}

// src/registerBabel.ts
var import_path3 = require("path");
var import_slash22 = __toESM(require("slash2"));
function registerBabel_default(opts) {
  const { cwd, only } = opts;
  const { opts: babelConfig } = getBabelConfig_default({
    target: "node",
    typescript: true,
    type: "esm"
  });
  require("@babel/register")(__spreadProps(__spreadValues({}, babelConfig), {
    extensions: [".es6", ".es", ".jsx", ".js", ".mjs", ".ts", ".tsx"],
    only: only.map((file) => (0, import_slash22.default)((0, import_path3.isAbsolute)(file) ? file : (0, import_path3.join)(cwd, file))),
    babelrc: false,
    cache: false
  }));
}

// src/utils/index.ts
var import_fs = require("fs");
var import_path4 = require("path");
function getExistFile({ cwd, files, returnRelative }) {
  for (const file of files) {
    const absFilePath = (0, import_path4.join)(cwd, file);
    if ((0, import_fs.existsSync)(absFilePath)) {
      return returnRelative ? file : absFilePath;
    }
  }
}

// src/getUserConfig.ts
var import_ajv = __toESM(require("ajv"));
var import_slash23 = __toESM(require("slash2"));
var import_path5 = require("path");
var import_fs2 = require("fs");

// src/schema.ts
var noEmptyStr = { type: "string", minLength: 1 };
var schema_default = {
  type: "object",
  additionalProperties: false,
  properties: {
    entry: {
      oneOf: [noEmptyStr, { type: "array", items: noEmptyStr }]
    },
    file: { type: "string" },
    outDir: { type: "string" },
    esm: {
      oneOf: [
        { type: "boolean" },
        {
          type: "object",
          additionalProperties: false,
          properties: {
            type: {
              type: "string",
              pattern: "^(rollup|babel)$"
            },
            file: noEmptyStr,
            mjs: { type: "boolean" },
            minify: { type: "boolean" },
            importLibToEs: {
              type: "boolean"
            },
            dist: { type: "string" },
            dir: noEmptyStr
          }
        }
      ]
    },
    cjs: {
      oneOf: [
        { type: "boolean" },
        {
          type: "object",
          additionalProperties: false,
          properties: {
            type: {
              type: "string",
              pattern: "^(rollup|babel)$"
            },
            file: noEmptyStr,
            minify: { type: "boolean" },
            lazy: { type: "boolean" },
            dist: { type: "string" }
          }
        }
      ]
    },
    extraBabelPlugins: {
      type: "array"
    },
    extraBabelPresets: {
      type: "array"
    },
    extraPostCSSPlugins: {
      type: "array"
    },
    extraRollupPlugins: {
      type: "array"
    },
    extraExternals: {
      type: "array"
    },
    externalsExclude: {
      type: "array"
    },
    cssModules: {
      oneOf: [{ type: "boolean" }, { type: "object" }]
    },
    extractCSS: {
      type: "boolean"
    },
    injectCSS: {
      oneOf: [{ type: "boolean" }, { instanceof: "Function" }]
    },
    autoprefixer: {
      type: "object"
    },
    include: {
      oneOf: [{ type: "string" }, { type: "object" }, { type: "array" }]
    },
    runtimeHelpers: {
      type: "boolean"
    },
    overridesByEntry: {
      type: "object"
    },
    nodeResolveOpts: {
      type: "object"
    },
    target: noEmptyStr,
    doc: {
      type: "object"
    },
    replace: {
      type: "object"
    },
    inject: {
      type: "object"
    },
    lessInRollupMode: {
      type: "object"
    },
    sassInRollupMode: {
      type: "object"
    },
    lessInBabelMode: {
      oneOf: [{ type: "boolean" }, { type: "object" }]
    },
    browserFiles: {
      type: "array"
    },
    nodeFiles: {
      type: "array"
    },
    nodeVersion: {
      type: "number"
    },
    disableTypeCheck: {
      type: "boolean"
    },
    preCommit: {
      type: "object",
      additionalProperties: false,
      properties: {
        eslint: { type: "boolean" },
        prettier: { type: "boolean" }
      }
    },
    typescriptOpts: {
      type: "object"
    },
    pkgs: {
      type: "array"
    },
    pkgFilter: {
      type: "object"
    },
    loose: {
      type: "boolean"
    }
  }
};

// src/getUserConfig.ts
function testDefault(obj) {
  return obj.default || obj;
}
var CONFIG_FILES = [
  ".rcdoc.build.js",
  ".rcdoc.build.cjs",
  ".rcdoc.build.jsx",
  ".rcdoc.build.ts"
];
var CLASSES = {
  Function
};
var extendAjv = (ajv) => {
  ajv.addKeyword("instanceof", {
    compile: function(schema) {
      var Class = CLASSES[schema];
      return function(data) {
        return data instanceof Class;
      };
    }
  });
  return ajv;
};
function getUserConfig_default({
  cwd,
  customPath
}) {
  let finalPath = "";
  if (customPath) {
    finalPath = (0, import_path5.isAbsolute)(customPath) ? customPath : (0, import_path5.resolve)(process.cwd(), customPath);
    if (!(0, import_fs2.existsSync)(finalPath)) {
      throw new Error(`can't found config file: ${customPath}`);
    }
  }
  const configFile = finalPath || getExistFile({
    cwd,
    files: CONFIG_FILES,
    returnRelative: false
  });
  if (configFile) {
    const userConfig = testDefault(require(configFile));
    const userConfigs = Array.isArray(userConfig) ? userConfig : [userConfig];
    userConfigs.forEach((userConfig2) => {
      const ajv = extendAjv(new import_ajv.default({ allErrors: true }));
      const isValid = ajv.validate(schema_default, userConfig2);
      if (!isValid) {
        const errors = ajv.errors.map(({ dataPath, message }, index2) => {
          return `${index2 + 1}. ${dataPath}${dataPath ? " " : ""}${message}`;
        });
        throw new Error(`
Invalid options in ${(0, import_slash23.default)((0, import_path5.relative)(cwd, configFile))}

${errors.join("\n")}
`.trim());
      }
    });
    return userConfig;
  } else {
    return {};
  }
}

// src/randomColor.ts
var import_chalk2 = __toESM(require("chalk"));
var colors = [
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "gray",
  "redBright",
  "greenBright",
  "yellowBright",
  "blueBright",
  "magentaBright",
  "cyanBright"
];
var index = 0;
var cache = {};
function randomColor_default(pkg) {
  if (!cache[pkg]) {
    const color = colors[index];
    let str = import_chalk2.default[color].bold(pkg);
    cache[pkg] = str;
    if (index === colors.length - 1) {
      index = 0;
    } else {
      index += 1;
    }
  }
  return cache[pkg];
}

// src/build.ts
function getBundleOpts(opts) {
  const { cwd, buildArgs = {}, rootConfig = {} } = opts;
  const entry = getExistFile({
    cwd,
    files: ["src/index.tsx", "src/index.ts", "src/index.jsx", "src/index.js"],
    returnRelative: true
  });
  const userConfig = getUserConfig_default({ cwd, customPath: buildArgs.config });
  const userConfigs = Array.isArray(userConfig) ? userConfig : [userConfig];
  return userConfigs.map((userConfig2) => {
    const bundleOpts = (0, import_lodash.merge)({
      entry
    }, rootConfig, userConfig2, buildArgs);
    return bundleOpts;
  });
}
function validateBundleOpts(bundleOpts, { cwd, rootPath }) {
  if (bundleOpts.runtimeHelpers) {
    const pkgPath = (0, import_path6.join)(cwd, "package.json");
    assert.ok((0, import_fs_extra2.existsSync)(pkgPath), `@babel/runtime dependency is required to use runtimeHelpers`);
    const pkg = JSON.parse((0, import_fs_extra2.readFileSync)(pkgPath, "utf-8"));
    assert.ok((pkg.dependencies || {})["@babel/runtime"], `@babel/runtime dependency is required to use runtimeHelpers`);
  }
  if (bundleOpts.cjs && bundleOpts.cjs.lazy) {
    throw new Error(`
cjs.lazy don't support rollup.
    `.trim());
  }
  if (!bundleOpts.esm && !bundleOpts.cjs) {
    throw new Error(`
None format of ${import_chalk3.default.cyan("cjs | esm")} is configured, checkout https://github.com/3lang3/rcdoc/packages/build for usage details.
`.trim());
  }
  if (bundleOpts.entry) {
    const tsConfigPath = (0, import_path6.join)(cwd, "tsconfig.json");
    const tsConfig = (0, import_fs_extra2.existsSync)(tsConfigPath) || rootPath && (0, import_fs_extra2.existsSync)((0, import_path6.join)(rootPath, "tsconfig.json"));
    if (!tsConfig && (Array.isArray(bundleOpts.entry) && bundleOpts.entry.some(isTypescriptFile) || !Array.isArray(bundleOpts.entry) && isTypescriptFile(bundleOpts.entry))) {
      import_signale2.default.info(`Project using ${import_chalk3.default.cyan("typescript")} but tsconfig.json not exists. Use default config.`);
    }
  }
}
function isTypescriptFile(filePath) {
  return filePath.endsWith(".ts") || filePath.endsWith(".tsx");
}
async function build(opts, extraOpts = {}) {
  const { cwd, rootPath, watch, buildArgs = {}, clean = true, needTransform = true } = opts;
  const { pkg } = extraOpts;
  const dispose = [];
  const customConfigPath = buildArgs.config && ((0, import_path6.isAbsolute)(buildArgs.config) ? buildArgs.config : (0, import_path6.join)(process.cwd(), buildArgs.config));
  registerBabel_default({
    cwd,
    only: customConfigPath ? CONFIG_FILES.concat(customConfigPath) : CONFIG_FILES
  });
  const pkgName = (typeof pkg === "string" ? pkg : pkg == null ? void 0 : pkg.name) || "unknown";
  function log(msg) {
    console.log(`${pkg ? `${randomColor_default(`${pkgName}`)}: ` : ""}${msg}`);
  }
  const bundleOptsArray = getBundleOpts(opts);
  for (const bundleOpts of bundleOptsArray) {
    validateBundleOpts(bundleOpts, { cwd, rootPath });
    if (clean) {
      log(import_chalk3.default.gray(`Clean dist directory`));
      (0, import_fs_extra2.remove)((0, import_path6.join)(cwd, "dist"));
    }
    if (bundleOpts.cjs) {
      log(`Build cjs with babel`);
      await babel_default({ cwd, rootPath, watch, dispose, type: "cjs", log, bundleOpts, needTransform });
    }
    if (bundleOpts.esm) {
      const esm = bundleOpts.esm;
      log(`Build esm with babel`);
      const importLibToEs = esm && esm.importLibToEs;
      await babel_default({
        cwd,
        rootPath,
        watch,
        dispose,
        type: "esm",
        importLibToEs,
        log,
        bundleOpts,
        needTransform
      });
    }
  }
  return dispose;
}
async function build_default(opts) {
  const dispose = await build(opts);
  return () => dispose.forEach((e) => e());
}

// src/index.ts
var src_default = build_default;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
