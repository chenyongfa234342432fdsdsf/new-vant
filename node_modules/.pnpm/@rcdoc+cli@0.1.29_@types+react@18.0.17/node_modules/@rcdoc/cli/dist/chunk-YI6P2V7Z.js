import {
  getMarkdownContentMeta,
  getTitleAndLangByFilepath
} from "./chunk-PRTLF3TM.js";
import {
  context_default
} from "./chunk-WOQRSCMF.js";
import {
  CWD,
  PROJECT_CLI_DIST_DIR,
  ROOT
} from "./chunk-D3YCLLHO.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-OKPPX6YV.js";

// src/compiler/gen-site-menu.ts
import glob from "fast-glob";
import path from "path";
import slash from "slash2";
import { kebabCase } from "lodash-es";
function getMenuDataByFilepath(includes, filePath, defaultLang) {
  const root = includes.find((p) => filePath.startsWith(path.join(ROOT, p)));
  const rootPath = path.join(ROOT, root);
  const { dir } = path.parse(filePath);
  let { title, lang = defaultLang } = getTitleAndLangByFilepath(filePath);
  const { headings, frontmatter } = getMarkdownContentMeta(filePath);
  const isBaseDir = dir === rootPath;
  const baseDir = path.join("/", path.relative(rootPath, dir));
  const defaultLangFile = title === "README";
  const routePath = path.join(baseDir, defaultLangFile ? "" : kebabCase(title));
  const relative = slash(path.relative(PROJECT_CLI_DIST_DIR, filePath));
  const component = `React.lazy(() => import(/* @vite-ignore */'${relative}'))`;
  let isLink = true;
  if ((frontmatter == null ? void 0 : frontmatter.link) === false) {
    isLink = false;
  }
  if (defaultLangFile && !isBaseDir) {
    title = path.basename(dir);
  }
  title = (frontmatter == null ? void 0 : frontmatter.title) || (headings == null ? void 0 : headings[0]) || title || "";
  let menu = {
    title: title.replace(/[\r\n]/g, ""),
    lang,
    relative,
    path: slash(routePath),
    langPath: slash(lang !== defaultLang ? path.join("/", lang, routePath) : routePath),
    filePath: slash(filePath),
    isLink,
    component
  };
  if (frontmatter == null ? void 0 : frontmatter.group) {
    menu.group = frontmatter == null ? void 0 : frontmatter.group;
  }
  return menu;
}
function resolveStaticMenus(userConfig) {
  const { locales, resolve } = userConfig;
  const defaultLang = !locales ? "" : locales[0][0];
  const menus = glob.sync(resolve.includes.map((dirPath) => slash(path.join(dirPath, "**/*.md"))), { ignore: resolve.excludes = [] }).map((filePath) => {
    const menu = getMenuDataByFilepath(resolve.includes, path.join(CWD, filePath), defaultLang);
    if (!locales && menu.lang)
      return false;
    if (locales && !locales.some((l) => l[0] === menu.lang))
      return false;
    return menu;
  }).filter(Boolean);
  return menus;
}
function genSiteMenu() {
  const menus = resolveStaticMenus(context_default.opts);
  const { locales, menus: configMenus, navs = [] } = context_default.opts;
  const hasNavs = !!navs.length;
  const langs = !locales ? false : locales.map((el) => el[0]);
  const defaultLang = !locales ? "" : langs[0];
  if (configMenus) {
    let loopIdx = 0;
    Object.entries(configMenus).forEach(([cfgMenuPath, cfgMenuCld]) => {
      let pathLang = Array.isArray(langs) ? langs.find((lang) => cfgMenuPath.startsWith("/" + lang)) || defaultLang : defaultLang;
      cfgMenuCld.forEach((menuItem) => {
        var _a, _b;
        (_a = menuItem.children) == null ? void 0 : _a.forEach((cPath, idx) => {
          const targetMenuIdx = menus.findIndex((el) => el.lang === pathLang && slash(path.join(pathLang !== defaultLang ? "/" + el.lang : "", el.path)) === cPath);
          if (targetMenuIdx === -1)
            return;
          const targetMenu = menus[targetMenuIdx];
          if (targetMenu && idx === 0) {
            targetMenu.group = { title: menuItem.title };
          }
          const correctIdx = idx + loopIdx;
          if (correctIdx !== targetMenuIdx) {
            [menus[correctIdx], menus[targetMenuIdx]] = [menus[targetMenuIdx], menus[correctIdx]];
          }
        });
        loopIdx += (_b = menuItem.children) == null ? void 0 : _b.length;
      });
    });
  }
  const mergeMenus = [...menus];
  if (Array.isArray(locales)) {
    localesCompatibleRoute(mergeMenus, locales, defaultLang);
  }
  const menuRoutes = mergeMenus.map(({ lang, title, path: path2, langPath, isLink, filePath, group }) => ({
    lang,
    title,
    path: path2,
    langPath,
    isLink,
    filePath,
    group
  }));
  const { allRedirectRoutes, langsMenus } = generateMenus(menuRoutes, langs || [""], hasNavs);
  return { routes: [...mergeMenus, ...allRedirectRoutes], menus: langsMenus };
}
function localesCompatibleRoute(allRoutes, locales, defaultLang) {
  const defaultLangRoutes = allRoutes.filter((r) => r.lang === defaultLang);
  const otherLang = locales[1][0];
  const othersLangRoutes = allRoutes.reduce((a, v) => {
    if (v.lang === otherLang) {
      if (!a[v.lang]) {
        a[v.lang] = [v];
      } else {
        a[v.lang].push(v);
      }
    }
    return a;
  }, { [otherLang]: [] });
  Object.entries(othersLangRoutes).forEach(([lang, routes]) => {
    defaultLangRoutes.forEach((defaultRoute) => {
      if (!routes.find((r) => r.path === defaultRoute.path)) {
        const idx = allRoutes.findIndex((r) => r.path === defaultRoute.path);
        allRoutes.splice(idx, 0, __spreadProps(__spreadValues({}, defaultRoute), {
          lang,
          langPath: lang !== defaultLang ? path.join("/", lang, defaultRoute.path) : defaultRoute.path
        }));
      }
    });
  });
}
function getRoutesDataByLang(data, hasNavs) {
  const redirectRoutes = [];
  function searchParent(children, parentPath) {
    let parent;
    children.some((cld) => {
      if (cld.path === parentPath && parentPath !== "/") {
        parent = cld;
        return true;
      }
      if (cld.children && cld.children.length) {
        parent = searchParent(cld.children, parentPath);
      }
    });
    return parent;
  }
  const routes = data.reduce((a, v) => {
    const dirname = path.dirname(v.path);
    const target = searchParent(a, dirname);
    if (target) {
      if (target.children) {
        target.children.push(v);
      } else {
        target.children = [v];
      }
      return a;
    }
    if (v.path !== "/") {
      a.push({ path: dirname, children: [v] });
      redirectRoutes.push({ redirect: v.langPath, path: path.dirname(v.langPath) });
    } else {
      if (!hasNavs)
        a.push(v);
    }
    return a;
  }, []);
  return [routes, redirectRoutes];
}
function generateMenus(data, langs, hasNavs) {
  const allRedirectRoutes = [];
  const langsMenus = langs.reduce((a, v) => {
    const flattenRoutes = data.filter((r) => r.lang === v);
    const [routes, redirectRoutes] = getRoutesDataByLang(flattenRoutes, hasNavs);
    a[v] = routes;
    allRedirectRoutes.push(...redirectRoutes);
    return a;
  }, {});
  return { allRedirectRoutes, langsMenus };
}

export {
  genSiteMenu
};
