var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_slash22 = __toESM(require("slash2"));
var import_pluginutils = require("@rollup/pluginutils");

// src/transformer.ts
var import_slash2 = __toESM(require("slash2"));
var import_parser = __toESM(require("@rcdoc/parser"));
var _exports, _contextCode;
var ExportedContent = class {
  constructor() {
    __privateAdd(this, _exports, []);
    __privateAdd(this, _contextCode, "");
  }
  addContext(contextCode) {
    __privateSet(this, _contextCode, __privateGet(this, _contextCode) + `${contextCode}
`);
  }
  addExporting(exported) {
    __privateGet(this, _exports).push(exported);
  }
  export() {
    return [__privateGet(this, _contextCode), `export { ${__privateGet(this, _exports).join(", ")} }`].join("\n");
  }
};
_exports = new WeakMap();
_contextCode = new WeakMap();
async function transformer(code, id, reactBabelPlugin, remarkOpts) {
  const content = new ExportedContent();
  const { demos, slugs, frontmatter, value, title, updatedTime } = await (0, import_parser.default)(code, id, remarkOpts);
  const compiledReactCode = `
      function ({ previewer = () => null, api = () => null }) {
        const Previewer = previewer;
        const API = api;
        return <div>
          ${value}
        </div>
      }
    `;
  const mdJsx = `
  import React from "react"

  ${demos.map((demo) => {
    var _a;
    const request = `${(0, import_slash2.default)(id)}.${demo.name}.${Buffer.from(id).toString("base64")}.${((_a = demo.props) == null ? void 0 : _a.lang) || "jsx"}`;
    demo.id = request;
    return `import ${demo.name}, { previewerProps as ${demo.name}PreviewerProps } from '${request}'`;
  }).join("\n")}
  const MdContent = ${compiledReactCode}
`;
  let mdJsxResult = { code: "" };
  try {
    mdJsxResult = await reactBabelPlugin.transform(mdJsx, `\0${id}.tsx`);
  } catch (e) {
    console.log("reactBabelPlugin error: ", e);
    mdJsxResult.code = `const MdContent = ''`;
  }
  content.addContext(mdJsxResult.code);
  content.addExporting("MdContent");
  let exportDemosStr = "";
  const exportDemos = demos.filter((el) => !el.inline);
  exportDemos.forEach((el, i) => {
    if (i === 0)
      exportDemosStr += "[";
    exportDemosStr += `{ Component: ${el.name}, key: '${el.props.key}', ...${JSON.stringify(el.props.meta)},`;
    exportDemosStr += "},";
    if (i === exportDemos.length - 1)
      exportDemosStr += "]";
  });
  if (!exportDemosStr.length) {
    exportDemosStr = "[]";
  }
  content.addContext(`const demos = ${exportDemosStr};`);
  content.addExporting("demos");
  content.addContext(`const frontmatter = ${JSON.stringify(frontmatter)};`);
  content.addExporting("frontmatter");
  content.addContext(`const slugs = ${JSON.stringify(slugs)};`);
  content.addExporting("slugs");
  content.addContext(`const filePath = "${id.replace(process.cwd(), "")}";`);
  content.addExporting("filePath");
  content.addContext(`const title = "${title}";`);
  content.addExporting("title");
  content.addContext(`const updatedTime = "${updatedTime}";`);
  content.addExporting("updatedTime");
  content.addContext(`export default (props) => {
    return props.children({ MdContent, demos, frontmatter, slugs, filePath, title, updatedTime })
  }`);
  return {
    code: content.export(),
    demos
  };
}

// src/index.ts
var CWD = process.cwd();
var PLUGIN_NAME = "@rcdoc/vitejs-plugin-react";
var FILE_PATH_EXPORT_NAME = "___vitePluginReactMdocCodestring___";
var cache = /* @__PURE__ */ new Map();
var importedIdSet = /* @__PURE__ */ new Map();
var pluginOptions = {
  include: /\.md$/,
  previewLangs: ["jsx", "tsx"]
};
var plugin = (options = {}) => {
  const userOptions = __spreadValues(__spreadValues({}, pluginOptions), options);
  let server;
  let remarkOpts;
  let reactBabelPlugin;
  const filter = (0, import_pluginutils.createFilter)(userOptions.include || /\.md$/, userOptions.exclude);
  return {
    name: PLUGIN_NAME,
    configResolved(resolvedConfig) {
      var _a;
      remarkOpts = __spreadValues({
        prefix: "MdocDemo",
        alias: getViteAlias((_a = resolvedConfig == null ? void 0 : resolvedConfig.resolve) == null ? void 0 : _a.alias)
      }, userOptions);
      reactBabelPlugin = resolvedConfig.plugins.find((el) => el.name === "vite:react-babel");
    },
    configureServer(_server) {
      server = _server;
    },
    resolveId(_id) {
      const id = (0, import_slash22.default)(_id);
      const mat = id.match(/\.md\.MdocDemo\d+\.(.*)\.(jsx|tsx)$/);
      if (mat && mat.length > 2) {
        const [, sourceIdBase64] = mat;
        const sourceId = Buffer.from(sourceIdBase64, "base64").toString("ascii");
        const idPath = id.startsWith(sourceId) ? id : import_path.default.join(CWD, id.substring(1));
        return idPath;
      }
    },
    load(_id) {
      let id = (0, import_slash22.default)(_id);
      const mat = id.match(/\.md\.MdocDemo(\d+)(\..*)\.(jsx|tsx)$/);
      if (mat && mat.length >= 2) {
        const [, index, sourceId, suffix] = mat;
        id = id.replace(sourceId, "");
        const mdFileName = id.replace(`.MdocDemo${index}.${suffix}`, "");
        const demos = cache.get(mdFileName);
        const demo = demos == null ? void 0 : demos[+index - 1];
        if (!demo)
          return null;
        if (demo.filePath) {
          return {
            code: `import ${demo.name}, { ${FILE_PATH_EXPORT_NAME} } from '${(0, import_slash22.default)(demo.filePath)}';
export default ${demo.name};
export const previewerProps = { code: ${FILE_PATH_EXPORT_NAME}, ...${JSON.stringify(demo.props)} }`,
            map: { mappings: "" }
          };
        }
        return {
          code: `${demo.code};
export const previewerProps = {code: ${JSON.stringify(demo.code)}, ...${JSON.stringify(demo.props)} }`,
          map: { mappings: "" }
        };
      }
      if (importedIdSet.has(id)) {
        const idSource = import_fs.default.readFileSync(id, "utf8");
        return `${idSource}
 export const ${FILE_PATH_EXPORT_NAME} = ${JSON.stringify(idSource)}`;
      }
    },
    async transform(code, id) {
      if (filter(id)) {
        const { code: content, demos } = await transformer(code, id, reactBabelPlugin, remarkOpts);
        cache.set((0, import_slash22.default)(id), demos);
        demos.forEach((demo) => {
          if (demo.filePath) {
            importedIdSet.set((0, import_slash22.default)(demo.filePath), id);
          }
        });
        return { code: content };
      }
    },
    async handleHotUpdate(ctx) {
      if (filter(ctx.file)) {
        const source = await ctx.read();
        const { demos } = await transformer(source, ctx.file, reactBabelPlugin, remarkOpts);
        cache.set((0, import_slash22.default)(ctx.file), demos);
        const updateModules = [];
        demos.forEach((demo) => {
          if (demo.filePath)
            return;
          const mods = server.moduleGraph.getModulesByFile(demo.id) || [];
          updateModules.push(...mods);
        });
        return [...ctx.modules, ...updateModules];
      }
    }
  };
};
var src_default = plugin;
function getViteAlias(alias = []) {
  if (!alias)
    return {};
  return alias.reduce((a, alia) => {
    if (typeof alia.find === "string" && typeof alia.replacement === "string") {
      a[alia.find] = alia["replacement"];
    }
    return a;
  }, {});
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
